<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>El Impostor - Host</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div class="container">
    <h1>ğŸ® El Impostor - Host</h1>

    <div id="join-view">
      <p class="text-center mb-20">Ãšnete como host para gestionar la partida</p>
      <form id="joinForm">
        <div class="form-group">
          <label for="name">Tu nombre:</label>
          <input type="text" id="name" name="name" placeholder="Ingresa tu nombre" required />
        </div>
        <button type="submit">ğŸš€ Unirse y Gestionar</button>
      </form>
    </div>

    <div id="game-view" class="hidden">
      <div class="player-header">
        <p>Host: <strong id="display-name"></strong></p>
        <button id="leave-btn" class="btn-danger btn-sm">ğŸšª Salir</button>
      </div>

      <!-- Game Settings -->
      <div class="form-group settings-section">
        <h2>âš™ï¸ ConfiguraciÃ³n de Partida</h2>
        <div class="settings-controls">
          <label class="toggle-container">
            <span>Modo de Juego:</span>
            <div class="mode-toggle">
              <button id="mode-manual" class="mode-btn active">Manual</button>
              <button id="mode-auto" class="mode-btn">AutomÃ¡tico</button>
              <button id="mode-local" class="mode-btn">Mismo Dispositivo</button>
            </div>
          </label>
          <label class="toggle-container mt-20">
            <span>Cantidad de Impostores:</span>
            <div class="impostor-selector">
              <input type="number" id="impostor-count" min="1" max="10" value="1" class="impostor-input">
            </div>
          </label>
          <p id="mode-description" class="text-sm italic text-gray mt-5">
            Los jugadores deben ingresar sus propias palabras.
          </p>
        </div>
      </div>

      <!-- Player Management -->
      <div id="word-section" class="form-group">
        <h2>ğŸ‘¥ GestiÃ³n de Jugadores</h2>

        <!-- Local player entry form -->
        <div id="local-player-entry" class="hidden">
          <form id="addLocalPlayerForm">
            <div class="form-group">
              <label for="local-name">Nombre del jugador:</label>
              <input type="text" id="local-name" name="name" placeholder="Ej: Juan" required />
            </div>
            <button type="submit" class="btn-success">â• AÃ±adir Jugador</button>
          </form>
        </div>

        <form id="wordForm">
          <div class="form-group">
            <label for="word">Agregar palabra para jugador actual:</label>
            <input type="text" id="word" name="word" placeholder="Palabra secreta" required />
          </div>
          <button type="submit" class="btn-success">ğŸ“ Agregar palabra</button>
        </form>
      </div>

      <!-- Players List -->
      <div class="flex justify-between align-center">
        <h2>ğŸ“‹ Lista de Jugadores</h2>
      </div>
      <ul id="players"></ul>

      <!-- Game Controls -->
      <div class="form-group">
        <h2>ğŸ¯ Control del Juego</h2>
        <div class="text-center">
          <button id="start" class="btn-success">ğŸš€ Iniciar partida</button>
        </div>
      </div>

      <!-- Reset Controls -->
      <div class="form-group">
        <h2>ğŸ”„ Reiniciar</h2>
        <div class="text-center">
          <button id="reset-words" class="btn-warning">ğŸ—‘ï¸ Reiniciar partida</button>
          <button id="reset" class="btn-danger">ğŸ’¥ Reiniciar todo</button>
        </div>
      </div>
    </div>

    <!-- Game Status Display -->
    <div id="gameStatus" class="game-status hidden">
      <h3>ğŸ“Š Estado del juego:</h3>
      <div id="statusContent"></div>
    </div>

    <!-- Reveal Sequence UI -->
    <div id="reveal-view" class="hidden">
      <div id="reveal-card" class="reveal-card">
        <h2 id="reveal-player-title">Turno de [Nombre]</h2>
        <div id="reveal-content" class="reveal-content-box hidden">
          <p id="reveal-role">Rol: [Rol]</p>
          <p id="reveal-word-box">Palabra: <strong id="reveal-word"></strong></p>
        </div>
        <div class="reveal-controls">
          <button id="reveal-btn" class="btn-primary">ğŸ‘ï¸ Revelar</button>
          <button id="next-player-btn" class="btn-success hidden">â¡ï¸ Siguiente Jugador</button>
          <button id="finish-reveal-btn" class="btn-success hidden">ğŸ Finalizar y Jugar</button>
        </div>
      </div>
    </div>

    <!-- Messages -->
    <div id="messages"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="game-client.js"></script>
  <script>
    // UI State Management
    function updateUIState(state, name) {
      const joinView = document.getElementById('join-view');
      const gameView = document.getElementById('game-view');
      const displayName = document.getElementById('display-name');

      if (state === 'joined') {
        joinView.classList.add('hidden');
        gameView.classList.remove('hidden');
        if (displayName) displayName.textContent = name;
      } else {
        joinView.classList.remove('hidden');
        gameView.classList.add('hidden');
        if (displayName) displayName.textContent = '';
      }
    }

    // Initialize state change handler
    gameClient.onStateChange = (state, name) => {
      updateUIState(state, name);
    };

    // Check initial state
    if (gameClient.playerName) {
      document.getElementById('name').value = gameClient.playerName;
    }

    // Custom message display for better UX
    window.showCustomMessage = function (message, type = 'info') {
      const messagesContainer = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${type}`;
      messageDiv.textContent = message;

      messagesContainer.appendChild(messageDiv);

      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 5000);
    };

    // Host-specific functionality
    class HostController {
      constructor() {
        this.setupHostFeatures();
        this.loadPlayers(); // Load players on page load
        this.handleGameStatus(); // Initial status load
      }

      async loadPlayers() {
        try {
          const players = await gameClient.getPlayers();
          this.players = players; // Store players locally for reordering
          this.displayPlayers(players);
        } catch (error) {
          console.error('Error loading players:', error);
        }
      }

      displayPlayers(players) {
        this.players = players; // Keep internal state in sync
        const list = document.getElementById("players");
        if (!list) return;
        list.innerHTML = "";

        if (players.length === 0) {
          const li = document.createElement("li");
          li.textContent = "No hay jugadores en el juego";
          li.style.fontStyle = "italic";
          li.style.color = "#666";
          list.appendChild(li);
          return;
        }

        players.forEach((player, index) => {
          const li = document.createElement("li");
          li.className = "player-item draggable";
          li.draggable = true;
          li.dataset.index = index;
          li.innerHTML = `
            <div class="player-info">
              <span class="player-name">${player.name}</span>
              <span class="status-indicator ${player.hasWord ? 'has-word' : 'no-word'}">
                ${player.hasWord ? 'âœ…' : 'âŒ'}
              </span>
            </div>
            <div class="drag-handle">â‰¡</div>
          `;

          // Drag and Drop Event Listeners
          li.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', index);
            li.classList.add('dragging');
          });

          li.addEventListener('dragover', (e) => {
            e.preventDefault();
            li.classList.add('drag-over');
          });

          li.addEventListener('dragleave', () => {
            li.classList.remove('drag-over');
          });

          li.addEventListener('drop', (e) => {
            e.preventDefault();
            li.classList.remove('drag-over');
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const targetIndex = index;
            if (draggedIndex !== targetIndex) {
              this.handleReorder(draggedIndex, targetIndex);
            }
          });

          li.addEventListener('dragend', () => {
            li.classList.remove('dragging');
          });

          list.appendChild(li);
        });
      }

      async handleReorder(fromIndex, toIndex) {
        const newPlayersOrder = [...this.players];
        const movedPlayer = newPlayersOrder.splice(fromIndex, 1)[0];
        newPlayersOrder.splice(toIndex, 0, movedPlayer);

        try {
          const names = newPlayersOrder.map(p => p.name);
          await gameClient.reorderPlayers(names);
          // UI updates via 'game:playersUpdated'
        } catch (error) {
          gameClient.showError(error);
          this.displayPlayers(this.players); // Revert UI
        }
      }

      async handleStartGame() {
        try {
          const result = await gameClient.startGame();
          gameClient.showSuccess(`ğŸ‰ ${result.message}`);

          // Refresh players list
          await this.loadPlayers();

        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleAddLocalPlayer(e, form) {
        const formData = new FormData(form);
        const name = formData.get('name');
        try {
          await gameClient.emitAsync('join', { name });
          form.reset();
          // UI updates via 'game:playersUpdated'
        } catch (error) {
          gameClient.showError(error);
        }
      }

      async startRevealSequence() {
        try {
          const status = await gameClient.getGameStatus();
          const players = await gameClient.getPlayers();
          const starterIndex = players.findIndex(p => p.name === status.starterPlayer);

          if (starterIndex !== -1) {
            const orderedPlayers = [];
            for (let i = 0; i < players.length; i++) {
              orderedPlayers.push(players[(starterIndex + i) % players.length]);
            }
            this.revealPlayers = orderedPlayers;
          } else {
            this.revealPlayers = [...players];
          }

          this.currentRevealIndex = 0;
          this.showRevealStep();
        } catch (error) {
          gameClient.showError(error);
        }
      }

      async showRevealStep() {
        const player = this.revealPlayers[this.currentRevealIndex];
        if (!player) return;

        try {
          const state = await gameClient.getPlayerState(player.name);

          const revealView = document.getElementById('reveal-view');
          const title = document.getElementById('reveal-player-title');
          const content = document.getElementById('reveal-content');
          const roleText = document.getElementById('reveal-role');
          const wordBox = document.getElementById('reveal-word-box');
          const wordText = document.getElementById('reveal-word');
          const revealBtn = document.getElementById('reveal-btn');
          const nextBtn = document.getElementById('next-player-btn');
          const finishBtn = document.getElementById('finish-reveal-btn');

          title.textContent = `Turno de: ${player.name}`;
          roleText.textContent = state.role === 'impostor' ? 'ğŸ‘º ERES EL IMPOSTOR' : 'ğŸ˜‡ ERES INOCENTE';
          roleText.className = state.role === 'impostor' ? 'role-info warning' : 'role-info success';

          if (state.role === 'player') {
            wordBox.classList.remove('hidden');
            wordText.textContent = state.word;
          } else {
            wordBox.classList.add('hidden');
          }

          content.classList.add('hidden');
          revealBtn.classList.remove('hidden');
          nextBtn.classList.add('hidden');
          finishBtn.classList.add('hidden');
          revealView.classList.remove('hidden');

          // Setup reveal click
          revealBtn.onclick = () => {
            content.classList.remove('hidden');
            revealBtn.classList.add('hidden');
            if (this.currentRevealIndex < this.revealPlayers.length - 1) {
              nextBtn.classList.remove('hidden');
            } else {
              finishBtn.classList.remove('hidden');
            }
          };

          nextBtn.onclick = () => {
            this.currentRevealIndex++;
            this.showRevealStep();
          };

          finishBtn.onclick = () => {
            revealView.classList.add('hidden');
            this.handleGameStatus();
          };

        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleGameStatus() {
        try {
          const name = gameClient.playerName;
          const status = await gameClient.getGameStatus();
          const statusDiv = document.getElementById('gameStatus');
          const contentDiv = document.getElementById('statusContent');

          let playerState = null;
          if (status.started && name) {
            try {
              playerState = await gameClient.getPlayerState(name);
            } catch (e) {
              console.warn("Could not get player state for host:", e);
            }
          }

          let html = `
            <p><strong>Estado:</strong> ${status.started ? 'ğŸŸ¢ Iniciado' : 'ğŸ”´ No iniciado'}</p>
            <p><strong>Modo:</strong> ${status.mode === 'automatic' ? 'ğŸ¤– AutomÃ¡tico' :
              status.mode === 'manual' ? 'ğŸ‘¤ Manual' :
                status.mode === 'local' ? 'ğŸ¤– AutomÃ¡tico + ğŸ  Local' : 'Desconocido'
            }</p>
            <p><strong>Jugadores:</strong> ${status.playerCount}</p>
          `;

          if (status.started && status.starterPlayer) {
            // Calculate play order
            const players = await gameClient.getPlayers();
            const starterIndex = players.findIndex(p => p.name === status.starterPlayer);

            if (starterIndex !== -1) {
              const order = [];
              for (let i = 0; i < players.length; i++) {
                order.push(players[(starterIndex + i) % players.length].name);
              }
              html += `<p><strong>Orden de juego:</strong><br> ${order.join(' â¡ï¸ ')}</p>`;
            } else {
              html += `<p><strong>Empieza:</strong> ${status.starterPlayer}</p>`;
            }
          }

          if (playerState) {
            if (playerState.role === 'impostor') {
              html += `<div class="role-info warning">ğŸ‘º ERES EL <strong>IMPOSTOR</strong></div>`;
            } else {
              html += `<div class="role-info success">ğŸ˜‡ ERES <strong>INOCENTE</strong><br>Palabra: <strong>${playerState.word}</strong></div>`;
            }
          }

          contentDiv.innerHTML = html;
          statusDiv.classList.remove('hidden');
          if (status.started) {
            statusDiv.classList.add('started');
          } else {
            statusDiv.classList.remove('started');
          }
        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleReset() {
        if (!confirm('Â¿EstÃ¡s seguro de que quieres reiniciar todo el juego? Se perderÃ¡n todos los jugadores y palabras.')) {
          return;
        }

        try {
          await gameClient.resetGame();
          gameClient.showSuccess('ğŸ”„ Juego reiniciado completamente');

          // Refresh players list
          await this.loadPlayers();
        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleResetWords() {
        if (!confirm('Â¿EstÃ¡s seguro de que quieres borrar todas las palabras? El juego se reiniciarÃ¡ pero los jugadores permanecerÃ¡n.')) {
          return;
        }

        try {
          await gameClient.resetWords();
          gameClient.showSuccess('ğŸ—‘ï¸ Palabras eliminadas y juego reiniciado');

          // Refresh players list
          await this.loadPlayers();
        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleLeave() {
        if (confirm('Â¿EstÃ¡s seguro de que quieres salir del panel de gestiÃ³n?')) {
          await gameClient.leaveGame();
        }
      }

      async updateSettings(settings) {
        try {
          await gameClient.updateSettings(settings);
          // UI UI updates via 'game:settingsUpdated'
        } catch (error) {
          gameClient.showError(error);
        }
      }

      applySettingsUI(settings) {
        const wordSection = document.getElementById('word-section');
        const localEntry = document.getElementById('local-player-entry');
        const manualBtn = document.getElementById('mode-manual');
        const autoBtn = document.getElementById('mode-auto');
        const localBtn = document.getElementById('mode-local');
        const desc = document.getElementById('mode-description');
        const wordForm = document.getElementById('wordForm');
        const impostorInput = document.getElementById('impostor-count');

        // Reset status
        [manualBtn, autoBtn, localBtn].forEach(b => b.classList.remove('active'));
        wordSection.classList.remove('hidden');
        localEntry.classList.add('hidden');
        wordForm.classList.remove('hidden');

        if (impostorInput) {
          impostorInput.value = settings.impostorCount || 1;
        }

        if (settings.mode === 'automatic') {
          wordForm.classList.add('hidden');
          autoBtn.classList.add('active');
          desc.textContent = "El juego elegirÃ¡ una palabra aleatoria de una lista predefinida.";
        } else if (settings.mode === 'local') {
          wordForm.classList.add('hidden');
          localEntry.classList.remove('hidden');
          localBtn.classList.add('active');
          desc.textContent = "Juega en un Ãºnico dispositivo, la selecciÃ³n de palabra es automÃ¡tica y agregarÃ¡s los jugadores uno por uno.";
        } else {
          manualBtn.classList.add('active');
          desc.textContent = "Los jugadores deben ingresar sus propias palabras.";
        }
      }

      setupHostFeatures() {
        // Setup host-specific buttons
        gameClient.setupButton('start', () => this.handleStartGame());
        gameClient.setupButton('reset', () => this.handleReset());
        gameClient.setupButton('reset-words', () => this.handleResetWords());
        gameClient.setupButton('leave-btn', () => this.handleLeave());

        gameClient.setupButton('mode-manual', () => this.updateSettings({ mode: 'manual' }));
        gameClient.setupButton('mode-auto', () => this.updateSettings({ mode: 'automatic' }));
        gameClient.setupButton('mode-local', () => this.updateSettings({ mode: 'local' }));

        const impostorInput = document.getElementById('impostor-count');
        if (impostorInput) {
          impostorInput.addEventListener('change', (e) => {
            const count = parseInt(e.target.value);
            if (count > 0) {
              this.updateSettings({ impostorCount: count });
            }
          });
        }

        gameClient.setupForm('addLocalPlayerForm', (e, form) => this.handleAddLocalPlayer(e, form));

        // Listen for real-time updates
        window.addEventListener('game:playersUpdated', (e) => {
          this.displayPlayers(e.detail);
          this.handleGameStatus(); // Refresh status info
        });

        window.addEventListener('game:settingsUpdated', (e) => {
          this.applySettingsUI(e.detail);
          this.handleGameStatus();
        });

        window.addEventListener('game:started', (e) => {
          this.handleGameStatus(); // Refresh status info
          if (gameClient.currentSettings?.mode === 'local' || document.getElementById('mode-local').classList.contains('active')) {
            this.startRevealSequence();
          }
        });

        window.addEventListener('game:reset', () => {
          const gameStatus = document.getElementById('gameStatus');
          if (gameStatus) gameStatus.classList.add('hidden');
          this.handleGameStatus(); // Refresh status info
        });
      }
    }

    // Initialize host controller when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.hostController = new HostController();
    });
  </script>
</body>

</html>