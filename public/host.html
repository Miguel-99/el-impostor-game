<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>El Impostor - Host</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div class="container">
    <h1>ğŸ® El Impostor - Host</h1>

    <div id="join-view">
      <p class="text-center mb-20">Ãšnete como host para gestionar la partida</p>
      <form id="joinForm">
        <div class="form-group">
          <label for="name">Tu nombre:</label>
          <input type="text" id="name" name="name" placeholder="Ingresa tu nombre" required />
        </div>
        <button type="submit">ğŸš€ Unirse y Gestionar</button>
      </form>
    </div>

    <div id="game-view" class="hidden">
      <div class="player-header">
        <p>Host: <strong id="display-name"></strong></p>
        <button id="leave-btn" class="btn-danger btn-sm">ğŸšª Salir</button>
      </div>

      <!-- Game Settings -->
      <div class="form-group settings-section">
        <h2>âš™ï¸ ConfiguraciÃ³n de Partida</h2>
        <div class="settings-controls">
          <label class="toggle-container">
            <span>Modo de Juego:</span>
            <div class="mode-toggle">
              <button id="mode-manual" class="mode-btn active">Manual</button>
              <button id="mode-auto" class="mode-btn">AutomÃ¡tico</button>
            </div>
          </label>
          <p id="mode-description" class="text-sm italic text-gray mt-5">
            Los jugadores deben ingresar sus propias palabras.
          </p>
        </div>
      </div>

      <!-- Player Management -->
      <div id="word-section" class="form-group">
        <h2>ğŸ‘¥ GestiÃ³n de Jugadores</h2>

        <form id="wordForm">
          <div class="form-group">
            <label for="word">Agregar palabra para jugador actual:</label>
            <input type="text" id="word" name="word" placeholder="Palabra secreta" required />
          </div>
          <button type="submit" class="btn-success">ğŸ“ Agregar palabra</button>
        </form>
      </div>

      <!-- Players List -->
      <div class="flex justify-between align-center">
        <h2>ğŸ“‹ Lista de Jugadores</h2>
      </div>
      <ul id="players"></ul>

      <!-- Game Controls -->
      <div class="form-group">
        <h2>ğŸ¯ Control del Juego</h2>
        <div class="text-center">
          <button id="start" class="btn-success">ğŸš€ Iniciar partida</button>
        </div>
      </div>

      <!-- Reset Controls -->
      <div class="form-group">
        <h2>ğŸ”„ Reiniciar</h2>
        <div class="text-center">
          <button id="reset-words" class="btn-warning">ğŸ—‘ï¸ Borrar palabras</button>
          <button id="reset" class="btn-danger">ğŸ’¥ Reiniciar todo</button>
        </div>
      </div>
    </div>

    <!-- Game Status Display -->
    <div id="gameStatus" class="game-status hidden">
      <h3>ğŸ“Š Estado del juego:</h3>
      <div id="statusContent"></div>
    </div>

    <!-- Messages -->
    <div id="messages"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="game-client.js"></script>
  <script>
    // UI State Management
    function updateUIState(state, name) {
      const joinView = document.getElementById('join-view');
      const gameView = document.getElementById('game-view');
      const displayName = document.getElementById('display-name');

      if (state === 'joined') {
        joinView.classList.add('hidden');
        gameView.classList.remove('hidden');
        if (displayName) displayName.textContent = name;
      } else {
        joinView.classList.remove('hidden');
        gameView.classList.add('hidden');
        if (displayName) displayName.textContent = '';
      }
    }

    // Initialize state change handler
    gameClient.onStateChange = (state, name) => {
      updateUIState(state, name);
    };

    // Check initial state
    if (gameClient.playerName) {
      document.getElementById('name').value = gameClient.playerName;
    }

    // Custom message display for better UX
    window.showCustomMessage = function (message, type = 'info') {
      const messagesContainer = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${type}`;
      messageDiv.textContent = message;

      messagesContainer.appendChild(messageDiv);

      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 5000);
    };

    // Host-specific functionality
    class HostController {
      constructor() {
        this.setupHostFeatures();
        this.loadPlayers(); // Load players on page load
        this.handleGameStatus(); // Initial status load
      }

      async loadPlayers() {
        try {
          const players = await gameClient.getPlayers();
          this.players = players; // Store players locally for reordering
          this.displayPlayers(players);
        } catch (error) {
          console.error('Error loading players:', error);
        }
      }

      displayPlayers(players) {
        this.players = players; // Keep internal state in sync
        const list = document.getElementById("players");
        if (!list) return;
        list.innerHTML = "";

        if (players.length === 0) {
          const li = document.createElement("li");
          li.textContent = "No hay jugadores en el juego";
          li.style.fontStyle = "italic";
          li.style.color = "#666";
          list.appendChild(li);
          return;
        }

        players.forEach((player, index) => {
          const li = document.createElement("li");
          li.className = "player-item draggable";
          li.draggable = true;
          li.dataset.index = index;
          li.innerHTML = `
            <div class="player-info">
              <span class="player-name">${player.name}</span>
              <span class="status-indicator ${player.hasWord ? 'has-word' : 'no-word'}">
                ${player.hasWord ? 'âœ…' : 'âŒ'}
              </span>
            </div>
            <div class="drag-handle">â‰¡</div>
          `;

          // Drag and Drop Event Listeners
          li.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', index);
            li.classList.add('dragging');
          });

          li.addEventListener('dragover', (e) => {
            e.preventDefault();
            li.classList.add('drag-over');
          });

          li.addEventListener('dragleave', () => {
            li.classList.remove('drag-over');
          });

          li.addEventListener('drop', (e) => {
            e.preventDefault();
            li.classList.remove('drag-over');
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const targetIndex = index;
            if (draggedIndex !== targetIndex) {
              this.handleReorder(draggedIndex, targetIndex);
            }
          });

          li.addEventListener('dragend', () => {
            li.classList.remove('dragging');
          });

          list.appendChild(li);
        });
      }

      async handleReorder(fromIndex, toIndex) {
        const newPlayersOrder = [...this.players];
        const movedPlayer = newPlayersOrder.splice(fromIndex, 1)[0];
        newPlayersOrder.splice(toIndex, 0, movedPlayer);

        try {
          const names = newPlayersOrder.map(p => p.name);
          await gameClient.reorderPlayers(names);
          // UI updates via 'game:playersUpdated'
        } catch (error) {
          gameClient.showError(error);
          this.displayPlayers(this.players); // Revert UI
        }
      }

      async handleStartGame() {
        try {
          const result = await gameClient.startGame();
          gameClient.showSuccess(`ğŸ‰ ${result.message}`);

          // Refresh players list
          await this.loadPlayers();

        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleGameStatus() {
        try {
          const name = gameClient.playerName;
          const status = await gameClient.getGameStatus();
          const statusDiv = document.getElementById('gameStatus');
          const contentDiv = document.getElementById('statusContent');

          let playerState = null;
          if (status.started && name) {
            try {
              playerState = await gameClient.getPlayerState(name);
            } catch (e) {
              console.warn("Could not get player state for host:", e);
            }
          }

          let html = `
            <p><strong>Estado:</strong> ${status.started ? 'ğŸŸ¢ Iniciado' : 'ğŸ”´ No iniciado'}</p>
            <p><strong>Modo:</strong> ${status.mode === 'automatic' ? 'ğŸ¤– AutomÃ¡tico' : 'ğŸ‘¤ Manual'}</p>
            <p><strong>Jugadores:</strong> ${status.playerCount}</p>
            <p><strong>Palabras:</strong> ${status.wordsCount}</p>
            ${status.starterPlayer ? `<p><strong>Jugador inicial:</strong> ${status.starterPlayer}</p>` : ''}
            ${status.hasCommonWord ? '<p><strong>Palabra comÃºn:</strong> âœ… Seleccionada</p>' : '<p><strong>Palabra comÃºn:</strong> âŒ No seleccionada</p>'}
          `;

          if (playerState) {
            if (playerState.role === 'impostor') {
              html += `<div class="role-info warning">ğŸ‘º ERES EL <strong>IMPOSTOR</strong></div>`;
            } else {
              html += `<div class="role-info success">ğŸ˜‡ ERES <strong>INOCENTE</strong><br>Palabra: <strong>${playerState.word}</strong></div>`;
            }
          }

          contentDiv.innerHTML = html;
          statusDiv.classList.remove('hidden');
          if (status.started) {
            statusDiv.classList.add('started');
          } else {
            statusDiv.classList.remove('started');
          }
        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleReset() {
        if (!confirm('Â¿EstÃ¡s seguro de que quieres reiniciar todo el juego? Se perderÃ¡n todos los jugadores y palabras.')) {
          return;
        }

        try {
          await gameClient.resetGame();
          gameClient.showSuccess('ğŸ”„ Juego reiniciado completamente');

          // Refresh players list
          await this.loadPlayers();
        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleResetWords() {
        if (!confirm('Â¿EstÃ¡s seguro de que quieres borrar todas las palabras? El juego se reiniciarÃ¡ pero los jugadores permanecerÃ¡n.')) {
          return;
        }

        try {
          await gameClient.resetWords();
          gameClient.showSuccess('ğŸ—‘ï¸ Palabras eliminadas y juego reiniciado');

          // Refresh players list
          await this.loadPlayers();
        } catch (error) {
          gameClient.showError(error);
        }
      }

      async handleLeave() {
        if (confirm('Â¿EstÃ¡s seguro de que quieres salir del panel de gestiÃ³n?')) {
          await gameClient.leaveGame();
        }
      }

      async updateMode(mode) {
        try {
          await gameClient.updateSettings({ mode });
          // UI UI updates via 'game:settingsUpdated'
        } catch (error) {
          gameClient.showError(error);
        }
      }

      applySettingsUI(settings) {
        const wordSection = document.getElementById('word-section');
        const manualBtn = document.getElementById('mode-manual');
        const autoBtn = document.getElementById('mode-auto');
        const desc = document.getElementById('mode-description');

        if (settings.mode === 'automatic') {
          wordSection.classList.add('hidden');
          autoBtn.classList.add('active');
          manualBtn.classList.remove('active');
          desc.textContent = "El juego elegirÃ¡ una palabra aleatoria de una lista predefinida.";
        } else {
          wordSection.classList.remove('hidden');
          manualBtn.classList.add('active');
          autoBtn.classList.remove('active');
          desc.textContent = "Los jugadores deben ingresar sus propias palabras.";
        }
      }

      setupHostFeatures() {
        // Setup host-specific buttons
        gameClient.setupButton('start', () => this.handleStartGame());
        gameClient.setupButton('reset', () => this.handleReset());
        gameClient.setupButton('reset-words', () => this.handleResetWords());
        gameClient.setupButton('leave-btn', () => this.handleLeave());

        gameClient.setupButton('mode-manual', () => this.updateMode('manual'));
        gameClient.setupButton('mode-auto', () => this.updateMode('automatic'));

        // Listen for real-time updates
        window.addEventListener('game:playersUpdated', (e) => {
          this.displayPlayers(e.detail);
          this.handleGameStatus(); // Refresh status info
        });

        window.addEventListener('game:settingsUpdated', (e) => {
          this.applySettingsUI(e.detail);
          this.handleGameStatus();
        });

        window.addEventListener('game:started', (e) => {
          this.handleGameStatus(); // Refresh status info
        });

        window.addEventListener('game:reset', () => {
          const gameStatus = document.getElementById('gameStatus');
          if (gameStatus) gameStatus.classList.add('hidden');
          this.handleGameStatus(); // Refresh status info
        });
      }
    }

    // Initialize host controller when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.hostController = new HostController();
    });
  </script>
</body>

</html>